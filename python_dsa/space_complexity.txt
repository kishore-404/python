# âœ… Definition:
# Space Complexity refers to the **total memory** (RAM) used by an algorithm or program
# in terms of the size of the input (n). It includes:
# ğŸ”¹ Memory used by variables, data structures, function calls, and recursion stacks.

# âœ… Why we need Space Complexity:
# ğŸ”¹ To write **memory-efficient code**
# ğŸ”¹ To avoid **Memory Errors / Crashes**
# ğŸ”¹ To understand trade-offs between **speed and space**
# ğŸ”¹ Critical for coding interviews and large-scale applications

# -------------------------------------------------------

# âœ… How to measure Space Complexity:
# Total space = **input space + auxiliary space**
# ğŸ”¹ Input space = size of input (usually given)
# ğŸ”¹ Auxiliary space = extra space used by the algorithm (variables, arrays, recursion)

# -------------------------------------------------------

# âœ… Common Space Complexities:

# ğŸ”¸ O(1) â€” Constant space
#     Uses same amount of memory regardless of input size
# ğŸ”¸ O(n) â€” Linear space
#     Memory grows linearly with input size (like creating a copy of the list)
# ğŸ”¸ O(nÂ²) â€” Quadratic space
#     Used in matrix or 2D table storage
# ğŸ”¸ O(log n) â€” Logarithmic space
#     Seen in recursive algorithms like binary search (log n call stack)

# -------------------------------------------------------

# âœ… Example 1: O(1) Space

def print_sum(arr):
    total = 0      # 1 variable
    for i in arr:
        total += i
    print(total)

# No matter the size of arr, memory for 'total' remains constant

# -------------------------------------------------------

# âœ… Example 2: O(n) Space

def double_elements(arr):
    result = []
    for x in arr:
        result.append(x * 2)
    return result

# Output list 'result' grows with input size

# -------------------------------------------------------

# âœ… Example 3: O(n) Recursive Space (Call Stack)

def factorial(n):
    if n == 0:
        return 1
    return n * factorial(n - 1)

# Each recursive call takes space â†’ n calls = O(n) space

# -------------------------------------------------------

# âœ… Comparison: Time vs Space

# Some algorithms use more space to gain speed (Dynamic Programming with memoization)
# Some use less space but take more time (Recursion without memoization)

# -------------------------------------------------------

# âœ… Tips to reduce space complexity:

# ğŸ”¹ Reuse variables
# ğŸ”¹ Modify input in-place (if allowed)
# ğŸ”¹ Use generators instead of lists for iteration
# ğŸ”¹ Avoid unnecessary copies of data

# -------------------------------------------------------

# âœ… Limitations:
# âŒ Space Complexity doesnâ€™t account for actual memory size (just relative growth)
# âŒ Real memory usage may be affected by interpreter, caching, OS, etc.

